# BCSV v1.3.0 - Streaming LZ4 Compression Implementation Plan

**Feature**: Replace batch compression with streaming LZ4 compression  
**Goal**: Achieve constant-time `writeRow()` with <1ms P99 latency  
**Target Release**: December 2025  
**Breaking Change**: Yes - file format v1.2.0 → v1.3.0

---

## ✅ Confirmed Design Decisions

All major design decisions have been finalized:

1. **Unbuffered writes** - Immediate write for true constant latency ✅
2. **Breaking change** - No v1.2.0 read support (users must convert) ✅
3. **64-bit checksums + chaining** - xxHash32 for header (24 bytes), xxHash64 for payload (8MB) ✅
4. **8 MB default packet size** - Configurable per file ✅
5. **ZoH Option A** - Compare raw (uncompressed) rows for speed ✅
6. **24-byte packet header** - No reserved field (row count from index) ✅
7. **VLE row lengths with offset+1** - Elegant encoding with ~40% overhead savings ✅
8. **File index mandatory in v1.3.0** - Stores last packet checksum + enables random access ✅
9. **Checksum chaining** - Payload checksum stored in next packet header (or file index for last) ✅

---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Solution Overview](#solution-overview)
3. [New File Format Specification](#new-file-format-specification)
4. [Implementation Tasks](#implementation-tasks)
5. [Performance Targets](#performance-targets)
6. [Migration Strategy](#migration-strategy)
7. [Testing Strategy](#testing-strategy)

---

## Problem Statement

### Current Issues (v1.2.0 Batch Compression)

**Unpredictable Write Latency**:
- `writeRow()` typically: 0.5-1.5 μs
- `writeRow()` when packet full: **10-30 ms** (compression spike)
- P99 latency: **Unacceptable for real-time systems**

**Why This Matters**:
- STM32F4 @ 1 KHz (1000 channels): 1ms budget per sample
- STM32F7 @ 10 KHz: 100μs budget per sample
- **Batch compression violates real-time requirements**

**Current Batch Process**:
```
writeRow() → accumulate in buffer → [buffer full] → 
  compress entire packet (10-30ms spike!) → write to disk → continue
```

---

## Solution Overview

### Streaming Compression Approach

**Per-Row Processing**:
```
writeRow() → compress single row (streaming) → 
  write length + compressed data → continue (constant time)
```

**Key Benefits**:
1. ✅ **Constant write latency**: No compression spikes
2. ✅ **Better compression**: LZ4 stream maintains cross-row context
3. ✅ **Incremental persistence**: Data written immediately (unbuffered)
4. ✅ **Crash resilience**: Can read partial packets
5. ✅ **Space efficiency**: VLE encoding saves ~40% on length overhead
6. ⚠️ **Trade-off**: 1-2 bytes overhead per row (vs batch)

**LZ4 Stream API**:
- `LZ4_createStream()` / `LZ4_resetStream()`
- `LZ4_compress_fast_continue()` - maintains dictionary across calls
- Dictionary preserved across row boundaries within packet
- Reset at packet boundaries for random access

---

## New File Format Specification

### File Structure Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        File Header (v1.3.0)                     │
│  - Version: 1.3.0                                               │
│  - Column definitions                                           │
│  - Compression level                                            │
│  - Flags (including streaming mode indicator)                   │
└─────────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────────┐
│                         Packet #1                               │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              Packet Header (24 bytes)                     │  │
│  │  - Magic: "PCKT" (0x50 0x43 0x4B 0x54)      [4 bytes]     │  │
│  │  - First row index: uint64_t                [8 bytes]     │  │
│  │  - Previous payload checksum: uint64_t      [8 bytes]     │  │
│  │    (0x0000000000000000 for first packet)                  │  │
│  │  - Header checksum: uint32_t (xxHash32)     [4 bytes]     │  │
│  └───────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              Packet Payload (streaming)                   │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │ Row 1:                                              │  │  │
│  │  │   - Length: VLE (offset+1, see spec below)          │  │  │
│  │  │   - Data: uint8_t[length] (LZ4 stream compressed)   │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │ Row 2:                                              │  │  │
│  │  │   - Length: VLE                                     │  │  │
│  │  │   - Data: uint8_t[length]                           │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  │  ...                                                      │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │ Row N:                                              │  │  │
│  │  │   - Length: VLE                                     │  │  │
│  │  │   - Data: uint8_t[length]                           │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │ Packet Terminator:                                  │  │  │
│  │  │   - VLE(1) = 0x01 (marks end of packet)             │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────┘  │
│  (No inline checksum - goes in Packet #2 header)                │
└─────────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────────┐
│                         Packet #2                               │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │              Packet Header (24 bytes)                     │  │
│  │  - Previous payload checksum: xxHash64(Packet #1)         │  │
│  │    ↑ Validates previous packet's payload                  │  │
│  └───────────────────────────────────────────────────────────┘  │
│  (Same structure as Packet #1)                                  │
└─────────────────────────────────────────────────────────────────┘
...
┌─────────────────────────────────────────────────────────────────┐
│                         Last Packet                             │
│  (Payload checksum stored in File Index, not next packet)       │
└─────────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────────┐
│                    File Index (at EOF) - MANDATORY              │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  Magic: "BIDX" (4 bytes)                                  │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │ PacketIndexEntry[0]:                                │  │  │
│  │  │   - headerOffset: uint64_t (file offset to header)  │  │  │
│  │  │   - firstRowIndex: uint64_t                         │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │ PacketIndexEntry[1]:                                │  │  │
│  │  │   - headerOffset: uint64_t                          │  │  │
│  │  │   - firstRowIndex: uint64_t                         │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  │  ...                                                      │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │ PacketIndexEntry[N]:                                │  │  │
│  │  │   - headerOffset: uint64_t                          │  │  │
│  │  │   - firstRowIndex: uint64_t                         │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  │  Magic: "EIDX" (4 bytes)                                  │  │
│  │  indexStartOffset: uint32_t (bytes from EOF to "BIDX")    │  │
│  │  lastPacketPayloadChecksum: uint64_t ← CRITICAL!          │  │
│  │  totalRowCount: uint64_t                                  │  │
│  │  indexChecksum: uint64_t (xxHash64 of entire index)       │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```
```

### Detailed Packet Format Specification

#### Packet Header (24 bytes, optimized)

```cpp
#pragma pack(push, 1)
struct PacketHeaderV3 {
    // Bytes 0-3: Magic number for packet identification
    char magic[4];                  // "PCKT" (0x50 0x43 0x4B 0x54)
    
    // Bytes 4-11: Row indexing
    uint64_t firstRowIndex;         // Absolute row index (0-based, file-wide)
                                    // Enables: random access, row counting
                                    // Row count = nextPacket.firstRowIndex - this.firstRowIndex
    
    // Bytes 12-19: Checksum chain for integrity
    uint64_t prevPayloadChecksum;   // xxHash64 of previous packet's payload
                                    // 0x0000000000000000 for first packet
                                    // Enables: packet sequence validation
    
    // Bytes 20-23: Header integrity
    uint32_t headerChecksum;        // xxHash32 of bytes 0-19
                                    // Validates header integrity independently
};
#pragma pack(pop)
static_assert(sizeof(PacketHeaderV3) == 24, "PacketHeaderV3 must be 24 bytes");
```

**Design Rationale**:
- **24 bytes total**: Compact, cache-line friendly
- **No reserved field**: Row count derived from file index (nextPacket.firstRowIndex - currentPacket.firstRowIndex)
- **Magic number first**: Fast rejection of invalid headers
- **32-bit header checksum**: Sufficient for 24 bytes, saves 4 bytes
- **64-bit payload checksum chain**: Stored in next packet's header (or file index for last packet)
- **Checksum chaining**: Detect missing/reordered packets

**Checksum Chain Flow**:
```
Writer:
  Packet 1 → calculate payload checksum → store in Packet 2.prevPayloadChecksum
  Packet 2 → calculate payload checksum → store in Packet 3.prevPayloadChecksum
  ...
  Last Packet → calculate payload checksum → store in FileFooter.lastPacketPayloadChecksum

Reader:
  Read Packet 1 → validate header checksum ✓
  Read Packet 2 → validate header checksum ✓, validate Packet 1 payload with Packet 2.prevPayloadChecksum ✓
  ...
  Read Last Packet → validate with FileFooter.lastPacketPayloadChecksum ✓
```

**Row Count Calculation**:
- During sequential write: Known from `firstRowIndex` difference
- With file index: `lastPacketRows = totalRows - lastPacket.firstRowIndex`
- Without index (incomplete file): Scan packet payload until terminator (resilient mode)

#### Row Length Encoding (Variable Length with Offset)

**Encoding Scheme**: VLE with offset by 1

```cpp
// Actual length → VLE encoding
Length 0 (ZoH)   → VLE(0) = 0x00
Terminator       → VLE(1) = 0x01  
Length 1         → VLE(2) = 0x02
Length 2         → VLE(3) = 0x03
Length 127       → VLE(128) = 0x80 0x01
Length 128       → VLE(129) = 0x81 0x01
Length 1000      → VLE(1001) = 0xE9 0x07
Length 8MB       → VLE(8388609) = ...
```

**VLE (Variable Length Encoding) Basics**:
- Each byte: bit 7 = continuation flag, bits 0-6 = data
- Bit 7 = 1: more bytes follow
- Bit 7 = 0: last byte
- Little-endian byte order

**Why Offset by 1 Works**:
- `VLE(0) = 0x00` → Natural encoding for ZoH (length = 0)
- `VLE(1) = 0x01` → Reserved for terminator
- `VLE(2+)` → Normal lengths (decode as `VLE - 1`)
- No ambiguity: 0x00 and 0x01 cannot appear as natural encoded lengths

**Encoding Examples**:

| Actual Length | Encoded VLE | Bytes | Overhead |
|---------------|-------------|-------|----------|
| 0 (ZoH) | 0x00 | 1 byte | 1 byte |
| 1 | 0x02 | 1 byte | 1 byte |
| 50 | 0x34 | 1 byte | 1 byte |
| 127 | 0x81 0x01 | 2 bytes | 2 bytes |
| 200 | 0xCA 0x01 | 2 bytes | 2 bytes |
| 1000 | 0xE9 0x07 | 2 bytes | 2 bytes |
| Terminator | 0x01 | 1 byte | 1 byte |

**Typical Overhead** (LZ4 compressed rows):
- 70-80% of rows: 50-200 bytes → **1-2 byte overhead**
- 10-20% ZoH repeats → **1 byte overhead**
- vs uint16_t: **~40% savings on length fields**

#### Payload Checksum (Chained in Next Header)

**Checksum Storage**:
- **Packet 1-N**: Payload checksum stored in **next** packet's `prevPayloadChecksum` field
- **Last packet**: Payload checksum stored in **File Index** `lastPacketPayloadChecksum` field

**No inline checksum after payload** - saves 8 bytes per packet!

**Checksum Coverage** (per packet):
```
xxHash64( VLE(row1.length) || row1.data || 
          VLE(row2.length) || row2.data || 
          ... 
          VLE(rowN.length) || rowN.data || 
          VLE(1) [terminator] )
```

**Implementation Functions**:

```cpp
// Encoding row length with offset
inline void writeRowLength(std::ostream& stream, uint64_t actualLength) {
    writeVLE(stream, actualLength + 1);  // Offset by 1
}

inline void writeZoH(std::ostream& stream) {
    stream.put(0x00);  // VLE(0)
}

inline void writeTerminator(std::ostream& stream) {
    stream.put(0x01);  // VLE(1)
}

// Decoding row length with offset
inline RowLengthResult readRowLength(std::istream& stream) {
    uint64_t encoded = readVLE(stream);
    
    if (encoded == 0) {
        return {RowType::ZOH_REPEAT, 0};
    } else if (encoded == 1) {
        return {RowType::PACKET_END, 0};
    } else {
        return {RowType::NORMAL_ROW, encoded - 1};  // Subtract offset
    }
}

// Standard VLE encode/decode
inline void writeVLE(std::ostream& stream, uint64_t value) {
    while (value >= 0x80) {
        stream.put(static_cast<uint8_t>((value & 0x7F) | 0x80));
        value >>= 7;
    }
    stream.put(static_cast<uint8_t>(value & 0x7F));
}

inline uint64_t readVLE(std::istream& stream) {
    uint64_t result = 0;
    int shift = 0;
    while (true) {
        uint8_t byte = stream.get();
        result |= static_cast<uint64_t>(byte & 0x7F) << shift;
        if ((byte & 0x80) == 0) break;
        shift += 7;
        if (shift > 63) throw std::runtime_error("VLE overflow");
    }
    return result;
}
```

### File Index Specification (Mandatory in v1.3.0)

The file index is **mandatory** and written at end-of-file (EOF) when the file is closed.

#### File Index Structure

```cpp
struct FileFooter {
    // Header
    char startMagic[4];              // "BIDX" (0x42 0x49 0x44 0x58)
    
    // Packet index entries (one per packet)
    struct PacketIndexEntry {
        uint64_t headerOffset;        // Absolute file offset to PacketHeader
        uint64_t firstRowIndex;       // First row index in this packet (0-based)
    };
    PacketIndexEntry packets[N];     // Variable length array
    
    // Footer
    char endMagic[4];                // "EIDX" (0x45 0x49 0x44 0x58)
    uint32_t indexStartOffset;       // Bytes from EOF to startMagic
    uint64_t lastPacketPayloadChecksum; // xxHash64 of last packet's payload
    uint64_t totalRowCount;          // Total number of rows in file
    uint64_t indexChecksum;          // xxHash64 of entire index (startMagic to totalRowCount)
};

// Footer is always at fixed offset from EOF:
// EOF - 28 bytes (footer size)
```

#### Index Size Calculation

```
Total size = 4 (BIDX) 
           + N × 16 (entries) 
           + 4 (EIDX)
           + 4 (indexStartOffset)
           + 8 (lastPacketPayloadChecksum)
           + 8 (totalRowCount)
           + 8 (indexChecksum)
         = 36 + N × 16 bytes

Example: 1000 packets = 36 + 16000 = 16,036 bytes (16 KB)
```

#### Reading File Index

**Fast Index Location** (footer at fixed EOF offset):

```cpp
// Seek to footer (28 bytes before EOF)
stream.seekg(-28, std::ios::end);

// Read footer
char endMagic[4];
uint32_t indexStartOffset;
uint64_t lastPacketPayloadChecksum;
uint64_t totalRowCount;
uint64_t indexChecksum;

stream.read(endMagic, 4);
if (memcmp(endMagic, "EIDX", 4) != 0) {
    // No valid index - file may be incomplete
    return handleMissingIndex();
}

stream.read(&indexStartOffset, 4);
stream.read(&lastPacketPayloadChecksum, 8);
stream.read(&totalRowCount, 8);
stream.read(&indexChecksum, 8);

// Seek to index start
stream.seekg(-static_cast<int64_t>(indexStartOffset), std::ios::end);

// Read and validate index
char startMagic[4];
stream.read(startMagic, 4);
if (memcmp(startMagic, "BIDX", 4) != 0) {
    throw std::runtime_error("Invalid file index");
}

// Read all packet entries...
```

#### Benefits of Mandatory Index

✅ **Last packet validation**: Store `lastPacketPayloadChecksum`  
✅ **Instant row count**: Read `totalRowCount` without scanning  
✅ **Random access**: Binary search on `firstRowIndex`  
✅ **Fast seeking**: Direct offset to any packet via `headerOffset`  
✅ **Integrity**: Full checksum chain validated  

#### Handling Incomplete Files (Resilient Mode)

**If index is missing** (crashed before close):

```cpp
// Reader detects missing/invalid index
if (!hasValidIndex()) {
    // Resilient mode: sequential scan only
    warn("File index missing - file may be incomplete");
    warn("Last packet payload cannot be validated");
    
    // Can still read all complete packets:
    // 1. Scan from beginning
    // 2. Read packet headers (validate header checksum)
    // 3. Validate packet chain (prevPayloadChecksum)
    // 4. Stop at first invalid packet or EOF
    
    return scanSequentially();
}
```

**Recovery guarantees**:
- ✅ All complete packets with valid headers readable
- ✅ Checksum chain validates sequence up to last complete packet
- ⚠️ Last packet payload checksum unvalidated (no index)
- ⚠️ Total row count unknown (must count during scan)

#### Writer Implementation

```cpp
class Writer {
    std::vector<PacketIndexEntry> packetIndex_;
    uint64_t lastPacketChecksum_ = 0;
    
    void flushPacket() {
        // Calculate current packet checksum
        uint64_t currentChecksum = payloadHasher_.finalize();
        
        // Record packet location in index
        packetIndex_.push_back({
            .headerOffset = currentPacketOffset_,
            .firstRowIndex = currentPacketFirstRow_
        });
        
        // If not first packet, write previous checksum to current header
        if (!packetIndex_.empty()) {
            currentHeader.prevPayloadChecksum = lastPacketChecksum_;
        }
        
        // Save for next iteration (or file index)
        lastPacketChecksum_ = currentChecksum;
    }
    
    void close() {
        // Flush any remaining packet
        if (hasUnflushedRows) {
            flushPacket();
        }
        
        // Write file index
        writeFileFooter(packetIndex_, lastPacketChecksum_, totalRows_);
    }
    
    void writeFileFooter(const std::vector<PacketIndexEntry>& entries,
                       uint64_t lastChecksum, uint64_t totalRows) {
        size_t indexStart = stream_.tellp();
        
        // Header
        stream_.write("BIDX", 4);
        
        // Entries
        for (const auto& entry : entries) {
            stream_.write(&entry.headerOffset, 8);
            stream_.write(&entry.firstRowIndex, 8);
        }
        
        // Footer
        stream_.write("EIDX", 4);
        
        uint32_t startOffset = static_cast<uint32_t>(
            stream_.tellp() + 28 - indexStart  // +28 for footer size
        );
        stream_.write(&startOffset, 4);
        stream_.write(&lastChecksum, 8);
        stream_.write(&totalRows, 8);
        
        // Calculate index checksum (everything except indexChecksum field)
        size_t indexEnd = stream_.tellp();
        stream_.seekg(indexStart);
        std::vector<char> indexData(indexEnd - indexStart);
        stream_.read(indexData.data(), indexData.size());
        
        uint64_t indexChecksum = xxHash64(indexData.data(), indexData.size());
        stream_.seekp(indexEnd);
        stream_.write(&indexChecksum, 8);
    }
};
```

---

### Packet Size Strategy

| Configuration | Default Size | Use Case |
|--------------|--------------|----------|
| **v1.3.0 Default** | **8 MB** | Best balance for compression + random access |
| **Small files** | 256 KB | Files < 10 MB |
| **Embedded** | 64 KB - 256 KB | RAM-constrained systems |
| **Large files** | 8 MB - 32 MB | Files > 1 GB |
| **Streaming only** | Disabled (0) | No packets, flat file format |

**Packet Termination Conditions**:
1. Payload size ≥ configured limit
2. Explicit `flush()` call
3. File close
4. (Future) Time-based flush for real-time guarantees

---

## Implementation Tasks

### Phase 1: Foundation (Week 1)

#### Task 1.1: Update File Format Version
- [ ] Change `BCSV_VERSION` to 1.3.0 in `definitions.h`
- [ ] Add new `FileFlags::STREAMING_COMPRESSION` flag
- [ ] Update `FileHeader` validation to support v1.3.0

#### Task 1.2: Create VLE Utilities
- [ ] Implement `writeVLE()` / `readVLE()` functions in `vle.hpp`
- [ ] Add `writeRowLength()` / `readRowLength()` with offset+1 encoding
- [ ] Unit tests for VLE encoding/decoding
- [ ] Edge cases: 0 (ZoH), 1 (terminator), large values

#### Task 1.3: Create New Packet Header
- [ ] Define `PacketHeaderV3` structure (24 bytes) in `packet_header.h`
- [ ] Implement checksum methods:
  - `updateHeaderChecksum()` - validate header integrity (xxHash32)
  - Payload checksum accumulated during packet write
- [ ] Add `validate()` method with magic number check
- [ ] Update packet reading logic for new header format

#### Task 1.4: LZ4 Stream Wrapper
- [ ] Create `lz4_stream.hpp` utility class
- [ ] Wrap `LZ4_stream_t` lifecycle (create/reset/free)
- [ ] Implement `compressRow()` method (LZ4_compress_fast_continue)
- [ ] Implement `decompressRow()` method (LZ4_decompress_safe_continue)
- [ ] Add unit tests for stream continuity

#### Task 1.5: File Index Structure
- [ ] Define `FileFooter` structure in `file_footer.h`
- [ ] Define `PacketIndexEntry` structure
- [ ] Implement index serialization/deserialization
- [ ] Add magic number validation ("BIDX", "EIDX")
- [ ] Implement index checksum calculation

**Questions for Discussion**:
1. ✅ **Packet header design finalized** (24 bytes, no reserved field)
2. ✅ **VLE encoding finalized** (offset+1 with sentinels)
3. ✅ **File index mandatory** (stores last packet checksum)

---

### Phase 2: Writer Implementation (Week 2)

#### Task 2.1: Streaming Writer Core
- [ ] Add `LZ4_stream_t*` to `Writer<T>` member variables
- [ ] Add `packetIndex_` vector for building file index
- [ ] Initialize stream on packet start
- [ ] Update `writeRow()`:
  ```cpp
  1. Serialize row to temp buffer
  2. Check if ZoH (compare raw with previous)
  3. If ZoH: write VLE(0)
  4. Else: compress using LZ4_compress_fast_continue()
  5. Write VLE(length+1)
  6. Write compressed data (unbuffered)
  7. Update streaming payload checksum
  8. Check packet size threshold
  ```
- [ ] Implement `flushPacket()`:
  ```cpp
  1. Write terminator VLE(1)
  2. Finalize payload checksum
  3. Save checksum for next packet header (or file index)
  4. Add entry to packetIndex_
  5. Reset LZ4 stream
  6. Reset checksum hasher
  ```

#### Task 2.2: File Index Writer
- [ ] Implement `writeFileFooter()` method
- [ ] Write "BIDX" magic
- [ ] Write all `PacketIndexEntry` records
- [ ] Write "EIDX" magic
- [ ] Write footer (indexStartOffset, lastPacketChecksum, totalRowCount)
- [ ] Calculate and write index checksum
- [ ] Called automatically in `close()`

#### Task 2.3: Checksum Chain Implementation
- [ ] Streaming xxHash64 for payload (accumulated per-row)
- [ ] xxHash32 for packet header (24 bytes)
- [ ] Store previous packet checksum in current header
- [ ] Store last packet checksum in file index

#### Task 2.4: ZoH Integration
- [ ] Detect unchanged rows (compare raw with previous)
- [ ] Write `VLE(0)` for ZoH repeats
- [ ] Skip compression for ZoH rows
- [ ] Handle first row in packet (always full)
- [ ] Include ZoH marker in payload checksum

---

### Phase 3: Reader Implementation (Week 2-3)

#### Task 3.1: File Index Reader
- [ ] Implement `readFileFooter()` method
- [ ] Seek to EOF - 28 bytes (footer location)
- [ ] Validate "EIDX" magic
- [ ] Read footer (indexStartOffset, lastPacketChecksum, totalRowCount)
- [ ] Seek to index start using indexStartOffset
- [ ] Validate "BIDX" magic
- [ ] Read all `PacketIndexEntry` records
- [ ] Validate index checksum
- [ ] Handle missing/invalid index (resilient mode)

#### Task 3.2: Streaming Reader Core
- [ ] Add `LZ4_streamDecode_t*` to `Reader<T>` member variables
- [ ] Load file index on open()
- [ ] Implement `readPacketHeader()`:
  ```cpp
  1. Search for "PCKT" magic
  2. Read full PacketHeaderV3 (24 bytes)
  3. Validate headerChecksum (xxHash32)
  4. Verify firstRowIndex matches expected
  5. Store prevPayloadChecksum for validation
  ```
- [ ] Implement `readNextRow()`:
  ```cpp
  1. Read VLE length
  2. If VLE(0) → ZoH repeat, copy previous row
  3. If VLE(1) → Packet end, validate payload checksum, read next header
  4. Else → length = VLE - 1, read compressed data
  5. Decompress using LZ4_decompress_safe_continue()
  6. Deserialize row
  7. Update payload checksum accumulator
  ```

#### Task 3.3: Checksum Validation
- [ ] Validate packet header checksums (xxHash32)
- [ ] Accumulate payload checksum as rows are read
- [ ] At packet terminator:
  - Validate against next packet's `prevPayloadChecksum`
  - Or validate last packet against `FileFooter.lastPacketPayloadChecksum`
- [ ] Implement checksum chain validation (detect missing packets)

#### Task 3.4: Resilient Reading (Missing Index)
- [ ] Handle incomplete packets (missing terminator)
- [ ] Validate checksum chains
- [ ] Skip corrupted packets in resilient mode
- [ ] Recover partial rows
- [ ] Sequential scan mode when index missing
- [ ] Warn user about missing index (file incomplete)

---

### Phase 4: Performance Optimization (Week 3)

#### Task 4.1: Benchmarking
- [ ] Create `streaming_performance_benchmark.cpp`
- [ ] Measure metrics:
  - P50, P95, P99, P99.9 write latency
  - Average throughput (rows/sec)
  - Memory usage
  - File size vs v1.2.0
  - Compression ratio vs v1.2.0

#### Task 4.2: Latency Optimization
- [ ] Profile `writeRow()` with perf/vtune
- [ ] Optimize hot paths (checksum, compression)
- [ ] Consider xxHash32 for header (faster, sufficient for 32 bytes)
- [ ] Pre-allocate compression buffers

#### Task 4.3: Compression Tuning
- [ ] Test different LZ4 acceleration factors
- [ ] Measure compression ratio vs speed trade-off
- [ ] Consider LZ4HC for high compression mode (batch at packet end?)

---

### Phase 5: Testing & Validation (Week 4)

#### Task 5.1: Unit Tests
- [ ] **VLE encoding/decoding**
  - [ ] Roundtrip tests (0, 1, 127, 128, 65535, uint64_max)
  - [ ] ZoH sentinel (VLE(0))
  - [ ] Terminator sentinel (VLE(1))
  - [ ] Offset encoding (length+1)
- [ ] **PacketHeaderV3**
  - [ ] Serialization/deserialization
  - [ ] Header checksum calculation (xxHash32)
  - [ ] Magic number validation
- [ ] **File Index**
  - [ ] Index serialization/deserialization
  - [ ] Footer location (EOF - 28 bytes)
  - [ ] Index checksum validation
  - [ ] Missing index detection
- [ ] **Checksum chain**
  - [ ] Payload checksum accumulation
  - [ ] Chain validation across packets
  - [ ] Last packet checksum in index
- [ ] **LZ4 stream**
  - [ ] Stream continuity across rows
  - [ ] Reset at packet boundaries
  - [ ] Decompression with stream context
- [ ] **ZoH encoding/decoding**
  - [ ] VLE(0) detection
  - [ ] Row comparison logic
  - [ ] First row in packet (always full)
- [ ] **Edge cases**:
  - [ ] Single row packet
  - [ ] Empty packet (valid?)
  - [ ] Maximum row size (8MB compressed)
  - [ ] Packet size limits
  - [ ] VLE overflow protection

#### Task 5.2: Integration Tests
- [ ] **Write/Read round-trip**
  - [ ] Write 1M rows, verify all readable
  - [ ] Validate file index
  - [ ] Validate checksum chain
- [ ] **Crash simulation**
  - [ ] Incomplete packet (missing terminator)
  - [ ] Missing file index
  - [ ] Corrupted packet header
  - [ ] Broken checksum chain
- [ ] **File index validation**
  - [ ] Index integrity after write
  - [ ] Random access using index
  - [ ] Row count from index
  - [ ] Last packet checksum validation
- [ ] **Checksum chain validation**
  - [ ] Sequential packet validation
  - [ ] Detect missing packets
  - [ ] Detect reordered packets
- [ ] **Large files** (>1 GB)
  - [ ] Multiple packets
  - [ ] Index size scaling
  - [ ] Memory usage
- [ ] **ZoH effectiveness**
  - [ ] Constant data compression
  - [ ] Sparse data compression

#### Task 5.3: Real-Time Tests
- [ ] STM32 simulator: 1000 channels @ 1 KHz
- [ ] Histogram of writeRow() latency
- [ ] Verify P99 < 1 ms
- [ ] Verify no spikes > 5 ms

#### Task 5.4: Fuzzing
- [ ] Fuzz packet headers (invalid checksums, magic)
- [ ] Fuzz row lengths (overflow, underflow)
- [ ] Fuzz compressed data (corruption)

---

## Performance Targets

### Latency Goals (writeRow)

| Metric | v1.2.0 (Batch) | v1.3.0 (Streaming) Target |
|--------|----------------|---------------------------|
| **P50 (median)** | 0.8 μs | ≤ 2 μs |
| **P95** | 1.2 μs | ≤ 5 μs |
| **P99** | **15 ms** ⚠️ | **< 1 ms** ✅ |
| **P99.9** | **30 ms** ⚠️ | **< 5 ms** ✅ |
| **Max** | 50+ ms | < 10 ms |

### Throughput Goals

| Workload | v1.2.0 | v1.3.0 Target |
|----------|--------|---------------|
| **Sequential write** | 411K rows/sec | ≥ 300K rows/sec* |
| **1000-channel stream** | 127K rows/sec | ≥ 100K rows/sec* |
| **Compression ratio** | 51.6% of CSV | 50-55% of CSV** |

\* *Lower throughput expected due to per-row overhead, but acceptable trade-off for constant latency*  
\*\* *Better compression possible due to LZ4 stream context*

### Memory Usage

| Component | v1.2.0 | v1.3.0 Target |
|-----------|--------|---------------|
| **Writer buffer** | 256 KB (default packet) | < 100 KB (row buffer + stream state) |
| **LZ4 stream state** | 0 | ~16-64 KB |
| **Peak allocation** | 256 KB | < 100 KB |

---

## Migration Strategy

### File Format Compatibility Matrix

| Reader Version | v1.0-1.1 Files | v1.2.0 Files | v1.3.0 Files |
|----------------|----------------|--------------|--------------|
| **v1.2.0** | ✅ | ✅ | ❌ |
| **v1.3.0** | ✅* | ✅* | ✅ |

\* *Read-only support, write always uses v1.3.0 format*

### User Migration Path

**Option 1: Rewrite (Recommended)**
```bash
# Convert old format to new
bcsv2csv old_v1.2.bcsv output.csv
csv2bcsv output.csv new_v1.3.bcsv
```

**Option 2: Dual Support (If implemented)**
```cpp
// Automatic version detection
bcsv::Reader reader;
reader.open("any_version.bcsv");  // Detects format automatically
```

### Breaking Changes Summary

| Change | Impact | Mitigation |
|--------|--------|------------|
| **Packet format** | Files incompatible | Conversion tool |
| **Header size** | 28 → 32 bytes | Version detection |
| **No row length array** | Different parsing | Dual reader |
| **Per-row length prefix** | New encoding | Transparent to API |

---

## Testing Strategy

### Test Pyramid

```
         /\
        /  \
       /    \      E2E Tests (5%)
      /      \     - Real hardware (STM32)
     /________\    - Large files (>1GB)
    /          \
   /            \  Integration Tests (15%)
  /              \ - Writer→Reader round-trip
 /________________\ - Crash recovery
/                  \
| Unit Tests (80%)  | - PacketHeader
|____________________| - LZ4 stream
                       - Checksum
```

### Continuous Performance Testing

**Benchmark Suite**:
1. **Latency histogram** (P50/P95/P99/P99.9)
2. **Throughput** (rows/sec)
3. **Compression ratio** (vs v1.2.0)
4. **Memory usage** (Valgrind/Massif)

**Regression Detection**:
- Run on every commit
- Alert if P99 > 1 ms
- Alert if throughput < 90% of v1.2.0

---

## ❓ **Open Questions**

### 1. ~~Packet Header Design~~ ✅ RESOLVED

**Decision**: 24-byte header without reserved field
- Row count calculated from `firstRowIndex` differences  
- File index will provide total row count
- Last packet row count = `totalRows - lastPacket.firstRowIndex`

### 2. ~~Write Buffering Strategy~~ ✅ RESOLVED

**Decision**: Unbuffered (immediate write)
- True constant latency
- No buffer flush spikes
- Measure syscall overhead in benchmarks

### 3. ~~Backward Compatibility~~ ✅ RESOLVED

**Decision**: Breaking change, no v1.2.0 read support
- Users can convert: `bcsv2csv old.bcsv | csv2bcsv new.bcsv`
- Simplifies codebase

### 4. ~~Checksum Strategy~~ ✅ RESOLVED

**Decision**: 64-bit checksums with chaining
- Header: 32-bit xxHash32 (sufficient for 24 bytes)
- Payload: 64-bit xxHash64 (essential for 8MB)
- Chain previous payload checksum in next header

### 5. ~~Packet Size Default~~ ✅ RESOLVED

**Decision**: 8 MB default (configurable)
- Optimal for compression ratio
- Good for random access with index (v1.4.0)
- Benchmarks show 4-8 MB is sweet spot

### 6. ~~ZoH Integration~~ ✅ RESOLVED

**Decision**: Compare raw (uncompressed) rows
- Faster than comparing compressed
- Simpler logic
- Exact equality check (no fuzzy matching)

### 7. ~~Row Length Encoding~~ ✅ RESOLVED

**Decision**: VLE with offset by 1
- `VLE(0) = 0x00` → ZoH repeat
- `VLE(1) = 0x01` → Packet terminator
- `VLE(N+1)` → Actual length N (for N ≥ 1)
- ~40% savings on length overhead vs uint16_t
- Supports unlimited row sizes

---

## Success Criteria

### Must Have (Release Blockers)
- ✅ P99 write latency < 1 ms
- ✅ No spikes > 5 ms in 1M row test
- ✅ All existing tests pass
- ✅ Compression ratio ≥ 90% of v1.2.0
- ✅ Backward read compatibility with v1.2.0

### Should Have (Desirable)
- ✅ Throughput ≥ 70% of v1.2.0
- ✅ Memory usage ≤ v1.2.0
- ✅ Better compression than v1.2.0 (LZ4 stream)
- ✅ Resilient reading (handle corruption)

### Could Have (Future)
- ⚠️ Async I/O support
- ⚠️ Adaptive packet sizing
- ⚠️ Multi-threaded compression

---

## Timeline

| Week | Focus | Deliverable |
|------|-------|-------------|
| **Week 1** | Foundation | New packet format, LZ4 wrapper |
| **Week 2** | Writer | Streaming writer complete |
| **Week 3** | Reader + Perf | Streaming reader, benchmarks |
| **Week 4** | Testing | All tests pass, documentation |

**Target Release**: December 15, 2025

---

## Next Steps

**All design decisions finalized!** ✅ Ready to begin implementation.

### Implementation Phases

**Phase 1: Foundation** (Week 1)
1. Create VLE encoding utilities (`vle.hpp`)
2. Define `PacketHeaderV3` structure (24 bytes)
3. Define `FileFooter` structure with footer
4. Update file version to 1.3.0
5. LZ4 stream wrapper class

**Phase 2: Writer** (Week 2)
1. Streaming writer with unbuffered writes
2. Per-row VLE encoding + LZ4 compression
3. ZoH detection (raw row comparison)
4. Packet termination + payload checksum accumulation
5. File index generation (written on close)
6. Checksum chaining (previous packet → current header)

**Phase 3: Reader** (Week 2-3)
1. File index reader (load on open)
2. VLE decoder
3. LZ4 stream decompression
4. Packet header validation + checksum chain
5. Payload checksum validation (from next header or index)
6. Resilient reading (handle incomplete files, missing index)

**Phase 4: Testing & Validation** (Week 4)
1. Unit tests (VLE, packet format, file index, checksums)
2. Integration tests (write/read round-trip, crash recovery)
3. Performance benchmarks (P99 latency, throughput)
4. Real-time tests (1000-channel @ 10 KHz)
5. File index validation tests

**Target Completion**: December 15, 2025

### Key Features Summary

✅ **Streaming compression** (constant-time writes)  
✅ **VLE row lengths** (~40% overhead savings)  
✅ **Checksum chaining** (packet sequence validation)  
✅ **Mandatory file index** (random access + last packet checksum)  
✅ **Crash resilient** (read up to last complete packet)  
✅ **8MB packets** (optimal compression + random access)  
✅ **Unbuffered writes** (true real-time performance)  

### Ready to Start?

With all design questions resolved, we can now begin Phase 1 implementation. Should I:

1. **Create VLE utility functions** (`include/bcsv/vle.hpp`)?
2. **Define new packet header structure** (update `packet_header.h`)?
3. **Define file index structure** (`include/bcsv/file_footer.h`)?
4. **Update version constants** (1.3.0 in `definitions.h`)?

Let me know which you'd like to tackle first!

---

**Document Version**: 3.0 (Design Finalized + File Index)  
**Last Updated**: November 8, 2025  
**Status**: ✅ Ready for Implementation  
**Authors**: GitHub Copilot + Tobias Weber
