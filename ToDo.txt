Decisions: The file format only supports 8bit/1byt memory alignment. We are not going to change that!
1. Update Documentation (bcsv general, format, cli tools, pybcsv)
2. Build a project using bcsv using cpp and python interfaces
3. Create and test C# wrapper
5. Improve compression:
    - implement dictionary compression for strings
    - implement ZigZag and variable length integer encoding, (also apply to string addresses and rowlength and length)
    - implement CHIMP/GORILA compression for floats
    - implement 1st and 2nd order hold schema (mark candidates in layout/header)
6. Create randomAccess / random/read methods:
    Row row(size_t index) {
        if(index == current_index+1) {
            //fall back to sequential
            readNext();
            return row_;
        }
        //check if row is in current packet, if not read packet required, build an file wide index if needed
        // use specific heuristics for ZoH, i.e. traverse several rows back and for to avoid complex reads
    }
    const auto& cell(size_t rowIndex, size_t colIndex) to directly access a cell, use RowView as a lightweight abstraction to avoid full deserilization
7. Create sampler (select data based on certain conditions)
    - support c++ interface (iterate over individual rows)
    - support python interface (iterate over individual rows, and block reads (pandas/numpy))
8. Add other datatypes (float8_t, float16_t, float_123_t, uint128_t, int128_t, BLOB)
9. Add concurent compression and writing using double buffering to not block row interface, when a packet needs to be written or read
10. Investigate stream write/stream read to avoid utilization spikes, that comes with packet based format
